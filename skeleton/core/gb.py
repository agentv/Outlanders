module_name = 'GameBoard'
version = '1.1.190206'

'''
module that contains the GameBoard, Sector, Player, 
and MasterRegistry (for game objects), MessageRegistry
 
it also contains test yokes for various system functions
including the GameShell that allows console operation
of game functions

The Gameboard hosts all of the actual game functions
such as randomizer (dice) and a sector map
'''

import gu
import cc 

import json
import math

Ship = cc.Ship  # localize these classes
Colony = cc.Colony

Location = gu.Location
NotePage = gu.NotePage
DieRoll = gu.VariableDie

# TODO - now that command-line processing is in place, use that to control
# testing as development proceeds

# Overall game elements, game board, players, and game squares (ie. sectors)

# TODO - convert this static dictionary into a routine that reads from a JSON file
doc = '''
This stock setup table sets the Gameboard to a known configuration
as a fixed way to start the game. In the long run, the plan should
be to read this material in from a JSON dataset and to have a way
for players to affect the startup somewhat before the game start
This data structure is referenced in the game setup routine
startPositions()
'''

stockSetup = {
  'Alexander': {
       'loc': Location(545, 250),
       'rssNames': ('Tesla 3', 'Captain Cook', 'Adm. Byrd') 
   },
  'Greg': { 
       'loc': Location(245, 550),
       'rssNames': ('Portsmouth', 'Lindbergh', 'Cousteau')
   },
  'Roosevelt': {
       'loc': Location(525, 310),
       'rssNames': ('Sanders', 'Babbage', 'Nelson')
   },
  'Napolean': {
       'loc': Location(340, 505),
       'rssNames': ('Botany Bay', 'Kennedy', 'Eisenhower')
   }
}

class MessageRegistry:
   ''' 
   This registry holds basic Note objects, but also manages sets of Notes such as
   Notebooks, Journals, and Queues
   '''
   register = {}

   def __init__(self):
      self.register = {}  # be sure
      
   def insertNote(self, nm, nt):
      # messages must come with a valid, unique name
      self.register[nm] = nt
      
   def hasNote(self, nm):
      return nm in self.register
   
   def dump(self):
      dumpstring = 'Message Registry:\n====================\n'
      rstring = ''
      for kid in self.register.keys():
         rstring += '%s -> %s\n' % (kid, self.register[kid])
      print '%s%s' % (dumpstring, rstring)


class MasterRegistry:
   ''' 
   The Registry holds the Player, Ship, and Colony objects
   Each object stored in the registry has a unique key
   generated by the NameMaker - it's not clear that this name
   will be used later although it's likely.
   
   It's probable that if the GameBoard and the MasterRegistry
   are serialized, that the entire game is preserved.
   '''
   register = {}

   def __init__(self):
      self.register = {}  # be sure it's empty upon creation
      self.nameMaker = gu.NameMaker()
      
   def addColony(self, c):
      # arg c is a fully instantiated colony
      pre = 'c'
      self.registryInsert(pre, c)
   
   def addShip(self, s):
      # arg s is a fully instantiated ship
      pre = 's'
      self.registryInsert(pre, s)

   def addPlayer(self, p):
      # second arg is a fully instantiated Player
      pre = 'p'
      self.registryInsert(pre, p)

   def registryInsert(self, prefix, element):
      # prefix is a type string, element is an object
      nameAppendage = self.nameMaker.grantName()
      nameCandidate = '%s%s' % (prefix, nameAppendage)
      while self.register.has_key(nameCandidate):
         nameAppendage = self.nameMaker.grantName()
         nameCandidate = '%s%s' % (prefix, nameAppendage)
      self.register[nameCandidate] = element
      
   def dump(self):
      dumpstring = 'Master Registry:\n===============\n'
      rstring = ''
      for o in self.register.keys():
         rstring += '%s -> %s\n' % (o, self.register[o])
      # rstring = '\n'.join(self.register.keys())
      print '%s%s' % (dumpstring, rstring)             


class GameBoard:
   ''' defines the characteristic of the full game board'''
   
   sectorTable = {}
   registry = {}  # object master registry
   legend = {}  # message master registry
   playerTable = []

   def __init__(self):
      self.sectorTable[0] = {}
      self.addSector(Sector(Location(0, 0))) # this may need more thought
      
      self.playerTable = []
      
      self.registry = MasterRegistry()
      
      self.legend = MessageRegistry()
      
      self.startPositions()  # temporary static setup
  
   def scanNeighbors(self, sect):
      # visits each sector within one hop and scans if needed
      xc = sect.location.xCoord
      yc = sect.location.yCoord
      for row in range(xc - 1, xc + 2):  # check each neighbor and establish sectors where needed
         for col in range(yc - 1, yc + 2):
            #rcstring = '(%d,%d)' % (row, col)
            if not row in self.sectorTable:
               self.sectorTable[row] = {}
            if not col in self.sectorTable[row]:
               self.addSector(Sector(Location(row, col)))
               
   def variableScan(self, sect, rad):
      # visits each sector within "rad" hops and scans if needed
      xc = sect.location.xCoord
      yc = sect.location.xCoord
      for row in gu.radius(rad):
         for col in gu.radius(rad):
            if not (xc + row) in self.sectorTable:
               self.sectorTable[xc + row] = {}
            if not col in self.sectorTable[yc + row]:
               self.addSector(Sector(Location(yc + row, col)))
   
   def addPlayer(self, p):
      self.playerTable.append(p)
      self.registry.addPlayer(p)
       
   def moveShip(self, ship, newLocation):
      oldLocation = ship.location
      # get sector for current ship's location
      oldSector = self.locateSector(oldLocation)
      # no failure mode is handled here
      jumpDistance = oldSector.distanceTo(newLocation)
      if jumpDistance > ship.jumpRange:
         return False
      
      # get sector for target location
      newSector = self.locateSector(newLocation)
      oldSector.removeShip(ship)
      newSector.addShip(ship)
      ship.location = newLocation
      return True
      
   def startPositions(self):
      for p in stockSetup.keys():
         plyr = Player(p)
         self.addPlayer(plyr)
         spot = stockSetup[p]['loc']
         
         sect = Sector(spot)
         self.addSector(sect)
         ''' one problem here is the static nature of this setup
             everyone has exactly 1 colony and exactly two ships
             a more progressive approach would be to allow an
             object-driven startup - for now, we're going to implement
             that with a "turn 0" that allows them to roll up a bunch 
             of surplus resources into whatever they wish
         '''
         
         co = Colony(plyr, stockSetup[p]['rssNames'][0], spot)
         plyr.addColony(co)
         self.registry.addColony(co)
         sect.hasColony = True
         
         sh = Ship(plyr, stockSetup[p]['rssNames'][1], spot)
         plyr.addShip(sh)
         self.registry.addShip(sh)
         sect.addShip(sh)
         
         sh = Ship(plyr, stockSetup[p]['rssNames'][2], spot)
         plyr.addShip(sh)
         self.registry.addShip(sh)
         sect.addShip(sh)
         
         homeColony = plyr.colonymaster[0]
         homeColony.goodsSurplus = 30
         homeColony.foodSurplus = 90
         homeColony.energySurplus = 200

   def addSector(self, s):
      xcoord = s.location.xCoord
      ycoord = s.location.yCoord
      if not xcoord in self.sectorTable:
         self.sectorTable[xcoord] = {}
      if not ycoord in self.sectorTable[xcoord]:
         self.sectorTable[xcoord][ycoord] = s
      else:
         print 'log an error because we tried to overwrite a sector'

   def locateSector(self, loc):
      ''' returns sector at the given location '''
      ndx = loc.xCoord
      ndy = loc.yCoord
      if not (self.sectorTable.has_key(ndx) and self.sectorTable[ndx].has_key(ndy)):
         s = Sector(Location(ndx, ndy))
         self.addSector(s)
         return s
      return self.sectorTable[ndx][ndy]
   
   def dump(self):
      for r in self.sectorTable.keys():
         for c in self.sectorTable[r].keys():
            self.sectorTable[r][c].dump()
            
   def getSector(self, loc=Location(0, 0)):  # this throws a key error if table not populated
      return (self.sectorTable[loc.xCoord][loc.yCoord])         


class Sector:
   ''' core characteristics of any Sector '''
   
   portAuthority = []  # list of ships in sector   
   hasColony = False  # flag used now to prevent multiple colonies in one sector

   resources = {
            'capacity': {'farm':10, 'energy':58, 'prod':44},
            'developed': {'farm':34, 'energy':99, 'prod':34}
   }

   # TODO - factor out these properties in favor of the map above   
   manufacturingCapacity = 0
   farmingCapacity = 0
   energyCapacity = 0
   
   manufacturingDeveloped = 0
   farmingDeveloped = 0
   energyDeveloped = 0
   
   ''' add/remove quotes at end of line to enable/disable
   colonyCommission = [] # list of colonies in sector - future development
   recreationalResources = 0 # future development (maybe)
   researchResources = 0 # future development (maybe)
   # end of future development section '''

   def __init__(self, l=Location(0, 0)):
      self.location = l
      xc = l.xCoord
      yc = l.yCoord
      
      boost = 0  # added to resource calc when we know where
      if xc < 400 or yc < 400: 
         boost += 40
      if xc < 200 or yc < 200:
            boost += 40
         
      self.manufacturingCapacity = 20 + DieRoll(30).roll() + boost
      self.farmingCapacity = 50 + DieRoll(30).roll() + boost
      self.energyCapacity = 70 + DieRoll(20).roll() + boost
                  
   def jdump(self):
      doc = ''' returns this sector as json '''
      return json.dumps(self)
      
      
      
      
   def dump(self):
      dumpstring = '''====================================
Sector at: %2d, %2d
Food (production/capacity): %d / %d
Energy (production/capacity): %d / %d
Goods (production/capacity): %d / %d
Colony Present: %s
====================================\n''' % (self.location.xCoord, self.location.yCoord,
                                          self.farmingDeveloped, self.farmingCapacity,
                                          self.energyDeveloped, self.energyCapacity,
                                          self.manufacturingDeveloped, self.manufacturingCapacity,
                                          self.hasColony)
      print dumpstring
      return dumpstring
   
   def addShip(self, s):
      # insert a ship into the sector portAuthority
      self.portAuthority.append(s)
      
   def removeShip(self, s):
      self.portAuthority.remove(s)
      
   def distanceTo (self, loc=Location(0, 0)):
      xDelta = abs(self.location.xCoord - loc.xCoord)
      yDelta = abs(self.location.yCoord - loc.yCoord)
      distance = math.sqrt(xDelta ** 2 + yDelta ** 2)
      return distance


class Player:
   # core characteristics of a single game player
   totalCropProduction = 0
   totalManufacturing = 0
   totalEnergyProduction = 0
   totalPopulation = 0
   generalMorale = 0
   playerName = ''
   playerID = ''
   sectorTable = {}

   def __init__ (self, nm='Caligula'):

      '''grant starting resources and update globals'''
      self.playerName = nm
      self.generalMorale = 0
      self.playerID = gu.NameMaker().grantName()
      
      self.colonymaster = []
      self.shipmaster = []
      
      self.dumpstring = '''
Player Name:             %s
Player ID:               %s
Total Population:        %d
Population Morale:       %d
Total Crop Production:   %d
Total Energy Production: %d
Total Goods Production:  %d
      ''' % (self.playerName, self.playerID, self.totalPopulation, self.generalMorale,
             self.totalCropProduction, self.totalEnergyProduction, self.totalManufacturing)
      
   ''' end of Player constructor '''

   def knowSector(self, s):
      ''' get location from sector s, then update my sectorTable to match '''
      
   def addColony(self, co):
      self.colonymaster.append(co)
      self.totalPopulation += co.population
      
   def addShip(self, sh):
      self.shipmaster.append(sh)
      self.totalPopulation += sh.population        

   def publish(self, note=NotePage()):
      note.setContent(self.dumpstring)
      return note
           
   def dump(self):
      print '%s' % self.dumpstring      
      for i in self.colonymaster:
         i.dump()
      for i in self.shipmaster:
         i.dump()
