#!/usr/local/bin/python

'''
module that contains the GameBoard, Sector, Player, 
and MasterRegistry (for game objects), MessageRegistry
 
it also contains test yokes for various system functions
including the GameShell that allows console operation
of game functions

The Gameboard hosts all of the actual game functions
such as randomizer (dice) and a sector map
'''

import cmd
import json
import gu
import cc 
import math

Ship = cc.Ship  # localize these classes
Colony = cc.Colony

Location = gu.Location
NotePage = gu.NotePage
DieRoll = gu.VariableDie

# TODO - now that command-line processing is in place, use that to control
# testing as development proceeds

# Overall game elements, game board, players, and game squares (ie. sectors)

# TODO - convert this static dictionary into a routine that reads from a JSON file
doc = '''
This stock setup table sets the Gameboard to a known configuration
as a fixed way to start the game. In the long run, the plan should
be to read this material in from a JSON dataset and to have a way
for players to affect the startup somewhat before the game start
This data structure is referenced in the game setup routine
startPositions()
'''

stockSetup = {
  'Alexander': {
       'loc': Location(545, 250),
       'rssNames': ('Tesla 3', 'Captain Cook', 'Adm. Byrd') 
   },
  'Greg': { 
       'loc': Location(245, 550),
       'rssNames': ('Portsmouth', 'Lindbergh', 'Cousteau')
   },
  'Roosevelt': {
       'loc': Location(525, 310),
       'rssNames': ('Sanders', 'Babbage', 'Nelson')
   },
  'Napolean': {
       'loc': Location(340, 505),
       'rssNames': ('Botany Bay', 'Kennedy', 'Eisenhower')
   }
}

'''
We might not need this custom encoder, but we'll put it here
in case we want to modify it to deal with unusual conditions
(it probably belongs in utils)
'''


class MyEncoder(json.JSONEncoder):

   def default(self, o):
      return o.__dict__


class MessageRegistry:
   ''' 
   This registry holds basic Note objects, but also manages sets of Notes such as
   Notebooks, Journals, and Queues
   '''
   register = {}

   def __init__(self):
      self.register = {}  # be sure
      
   def insertNote(self, nm, nt):
      # messages must come with a valid, unique name
      self.register[nm] = nt
      
   def hasNote(self, nm):
      return nm in self.register
   
   def dump(self):
      dumpstring = 'Message Registry:\n====================\n'
      rstring = ''
      for kid in self.register.keys():
         rstring += '%s -> %s\n' % (kid, self.register[kid])
      print '%s%s' % (dumpstring, rstring)


class MasterRegistry:
   ''' 
   The Registry holds the Player, Ship, and Colony objects
   Each object stored in the registry has a unique key
   generated by the NameMaker - it's not clear that this name
   will be used later although it's likely.
   
   It's probable that if the GameBoard and the MasterRegistry
   are serialized, that the entire game is preserved.
   '''
   register = {}

   def __init__(self):
      self.register = {}  # be sure it's empty upon creation
      self.nameMaker = gu.NameMaker()
      
   def addColony(self, c):
      # arg c is a fully instantiated colony
      pre = 'c'
      self.registryInsert(pre, c)
   
   def addShip(self, s):
      # arg s is a fully instantiated ship
      pre = 's'
      self.registryInsert(pre, s)

   def addPlayer(self, p):
      # second arg is a fully instantiated Player
      pre = 'p'
      self.registryInsert(pre, p)

   def registryInsert(self, prefix, element):
      # prefix is a type string, element is an object
      nameAppendage = self.nameMaker.grantName()
      nameCandidate = '%s%s' % (prefix, nameAppendage)
      while self.register.has_key(nameCandidate):
         nameAppendage = self.nameMaker.grantName()
         nameCandidate = '%s%s' % (prefix, nameAppendage)
      self.register[nameCandidate] = element
      
   def dump(self):
      dumpstring = 'Master Registry:\n===============\n'
      rstring = ''
      for o in self.register.keys():
         rstring += '%s -> %s\n' % (o, self.register[o])
      # rstring = '\n'.join(self.register.keys())
      print '%s%s' % (dumpstring, rstring)             


class GameBoard:
   ''' defines the characteristic of the full game board'''
   
   sectorTable = {}
   registry = {}  # object master registry
   legend = {}  # message master registry
   playerTable = []

   def __init__(self):
      self.sectorTable[0] = {}
      self.addSector(Sector(Location(0, 0)))
      
      self.playerTable = []
      
      self.registry = MasterRegistry()
      
      self.legend = MessageRegistry()
      
      self.startPositions()  # temporary static setup
  
   def scanNeighbors(self, sect):
      # visits each sector within one hop and scans if needed
      xc = sect.location.xCoord
      yc = sect.location.yCoord
      for row in range(xc - 1, xc + 2):  # check each neighbor and establish sectors where needed
         for col in range(yc - 1, yc + 2):
            #rcstring = '(%d,%d)' % (row, col)
            if not row in self.sectorTable:
               self.sectorTable[row] = {}
            if not col in self.sectorTable[row]:
               self.addSector(Sector(Location(row, col)))
               
   def variableScan(self, sect, rad):
      # visits each sector within "rad" hops and scans if needed
      xc = sect.location.xCoord
      yc = sect.location.xCoord
      for row in gu.radius(rad):
         for col in gu.radius(rad):
            if not (xc + row) in self.sectorTable:
               self.sectorTable[xc + row] = {}
            if not col in self.sectorTable[yc + row]:
               self.addSector(Sector(Location(yc + row, col)))
   
   def addPlayer(self, p):
      self.playerTable.append(p)
      self.registry.addPlayer(p)
       
   def moveShip(self, ship, newLocation):
      oldLocation = ship.location
      # get sector for current ship's location
      oldSector = self.locateSector(oldLocation)
      # no failure mode is handled here
      jumpDistance = oldSector.distanceTo(newLocation)
      if jumpDistance > ship.jumpRange:
         return False
      
      # get sector for target location
      newSector = self.locateSector(newLocation)
      oldSector.removeShip(ship)
      newSector.addShip(ship)
      ship.location = newLocation
      return True
      
   def startPositions(self):
      for p in stockSetup.keys():
         plyr = Player(p)
         self.addPlayer(plyr)
         spot = stockSetup[p]['loc']
         
         sect = Sector(spot)
         self.addSector(sect)
         ''' one problem here is the static nature of this setup
             everyone has exactly 1 colony and exactly two ships
             a more progressive approach would be to allow an
             object-driven startup - for now, we're going to implement
             that with a "turn 0" that allows them to roll up a bunch 
             of surplus resources into whatever they wish
         '''
         
         co = Colony(plyr, stockSetup[p]['rssNames'][0], spot)
         plyr.addColony(co)
         self.registry.addColony(co)
         sect.hasColony = True
         
         sh = Ship(plyr, stockSetup[p]['rssNames'][1], spot)
         plyr.addShip(sh)
         self.registry.addShip(sh)
         sect.addShip(sh)
         
         sh = Ship(plyr, stockSetup[p]['rssNames'][2], spot)
         plyr.addShip(sh)
         self.registry.addShip(sh)
         sect.addShip(sh)
         
         homeColony = plyr.colonymaster[0]
         homeColony.goodsSurplus = 30
         homeColony.foodSurplus = 90
         homeColony.energySurplus = 200

   def addSector(self, s):
      xcoord = s.location.xCoord
      ycoord = s.location.yCoord
      if not xcoord in self.sectorTable:
         self.sectorTable[xcoord] = {}
      if not ycoord in self.sectorTable[xcoord]:
         self.sectorTable[xcoord][ycoord] = s
      else:
         print 'log an error because we tried to overwrite a sector'

   def locateSector(self, loc):
      ''' returns sector at the given location '''
      ndx = loc.xCoord
      ndy = loc.yCoord
      if not (self.sectorTable.has_key(ndx) and self.sectorTable[ndx].has_key(ndy)):
         s = Sector(Location(ndx, ndy))
         self.addSector(s)
         return s
      return self.sectorTable[ndx][ndy]
   
   def dump(self):
      for r in self.sectorTable.keys():
         for c in self.sectorTable[r].keys():
            self.sectorTable[r][c].dump()
            
   def getSector(self, loc=Location(0, 0)):  # this throws a key error if table not populated
      return (self.sectorTable[loc.xCoord][loc.yCoord])         


class Sector:
   ''' core characteristics of any Sector '''
   
   portAuthority = []  # list of ships in sector   
   hasColony = False  # flag used now to prevent multiple colonies in one sector
   resources = {
            'capacity': {'farm':10, 'energy':58, 'prod':44},
            'developed': {'farm':34, 'energy':99, 'prod':34}
   }

   # TODO - factor out these properties in favor of the map above   
   manufacturingCapacity = 0
   farmingCapacity = 0
   energyCapacity = 0
   
   manufacturingDeveloped = 0
   farmingDeveloped = 0
   energyDeveloped = 0
   
   ''' add/remove quotes at end of line to enable or disable 
   colonyCommission = [] # list of colonies in sector - future development
   recreationalResources = 0 # future development (maybe)
   researchResources = 0 # future development (maybe)
   # end of future development section '''

   def __init__(self, l=Location(0, 0)):
      self.location = l
      xc = l.xCoord
      yc = l.yCoord
      
      boost = 0  # added to resource calc when we know where
      if xc < 400 or yc < 400: 
         boost += 40
      if xc < 200 or yc < 200:
            boost += 40
         
      self.manufacturingCapacity = 20 + DieRoll(30).roll() + boost
      self.farmingCapacity = 50 + DieRoll(30).roll() + boost
      self.energyCapacity = 70 + DieRoll(20).roll() + boost
                  
   def dump(self):
      dumpstring = '''====================================
Sector at: %2d, %2d
Food (production/capacity): %d / %d
Energy (production/capacity): %d / %d
Goods (production/capacity): %d / %d
Colony Present: %s
====================================''' % (self.location.xCoord, self.location.yCoord,
                                          self.farmingDeveloped, self.farmingCapacity,
                                          self.energyDeveloped, self.energyCapacity,
                                          self.manufacturingDeveloped, self.manufacturingCapacity,
                                          self.hasColony)
      print dumpstring
   
   def addShip(self, s):
      # insert a ship into the sector portAuthority
      self.portAuthority.append(s)
      
   def removeShip(self, s):
      self.portAuthority.remove(s)
      
   def distanceTo (self, loc=Location(0, 0)):
      xDelta = abs(self.location.xCoord - loc.xCoord)
      yDelta = abs(self.location.yCoord - loc.yCoord)
      distance = math.sqrt(xDelta ** 2 + yDelta ** 2)
      return distance


class Player:
   # core characteristics of a single game player
   totalCropProduction = 0
   totalManufacturing = 0
   totalEnergyProduction = 0
   totalPopulation = 0
   generalMorale = 0
   playerName = ''
   playerID = ''
   sectorTable = {}

   def __init__ (self, nm='Caligula'):

      '''grant starting resources and update globals'''
      self.playerName = nm
      self.generalMorale = 0
      self.playerID = gu.NameMaker().grantName()
      
      self.colonymaster = []
      self.shipmaster = []
      
      self.dumpstring = '''
Player Name:             %s
Player ID:               %s
Total Population:        %d
Population Morale:       %d
Total Crop Production:   %d
Total Energy Production: %d
Total Goods Production:  %d
      ''' % (self.playerName, self.playerID, self.totalPopulation, self.generalMorale,
             self.totalCropProduction, self.totalEnergyProduction, self.totalManufacturing)
      
   ''' end of Player constructor '''

   def knowSector(self, s):
      ''' get location from sector s, then update my sectorTable to match '''
      
   def addColony(self, co):
      self.colonymaster.append(co)
      self.totalPopulation += co.population
      
   def addShip(self, sh):
      self.shipmaster.append(sh)
      self.totalPopulation += sh.population        

   def publish(self, note=NotePage()):
      note.setContent(self.dumpstring)
      return note
           
   def dump(self):
      print '%s' % self.dumpstring      
      for i in self.colonymaster:
         i.dump()
      for i in self.shipmaster:
         i.dump()


class GameShell(cmd.Cmd):
   ''' we have a global Gameboard structure called g, estabalished in preloop() 
   this whole class is a giant hack
   its purpose is simply to provide a test bed for game functions
   
   TODO - This shell should be moved from the current file into a test/shell/Gameshell.py file
   '''
   
   # overrides
   prompt = '\nPODS command: $ '
   
   # globals for easy shell control
   activePlayer = Player()
   activeShip = Ship(Player())
   activeColony = Colony(Player())
   activeSector = Sector()
   
   def preloop(self):
      cmd.Cmd.preloop(self)
      self.g = GameBoard()
      
   def postloop(self):
      print 'Thanks for playing!\n'
   
   def do_moveship(self, line):
      choice = gu.get_tty_input('x location? ')
      xspot = int(choice)
      choice = gu.get_tty_input('Y location? ')
      yspot = int(choice)
      rslt = self.g.moveShip(self.activeShip, Location(xspot, yspot))
      if rslt:
         print 'that worked!'
      else:
         print 'that did not work'
      
   def help_dumpplayers(self):
      print 'show details for all players'

   def do_dumpplayers(self, line):
      print 'Details for all Players: '
      for plyr in self.g.playerTable:
         print plyr.playerName
         plyr.dump()
   
   def help_showplayers(self):
      print 'display a list of all players'

   def do_showplayers(self, line):
      print 'These are the Players:'
      ndx = 1
      for plyr in self.g.playerTable:
         print '[%d] %s' % (ndx, plyr.playerName)
         ndx += 1   

   def help_selectplayer(self):
      print 'choose active player from a numbered list'

   def do_selectplayer (self, line):
      self.do_showplayers(line)
      choice = gu.get_tty_input('Which one? ')
      print 'You chose: [%s]' % choice
      self.activePlayer = self.g.playerTable[int(choice) - 1]    
   
   def help_selectship(self):
      print 'select active ship from a numbered list'

   def do_showships(self, line):
      ndx = 1
      print 'These are the ships for %s' % self.activePlayer.playerName
      for ship in self.activePlayer.shipmaster:
         print '[%d] %s' % (ndx, ship.name)
         ndx += 1

   def do_selectship(self, line):
      self.do_showships(line)
      choice = gu.get_tty_input('Which one? ')
      print 'You chose [%s]' % choice
      self.activeShip = self.activePlayer.shipmaster[int(choice) - 1]
      loc = self.activeShip.location
      self.activeSector = self.g.locateSector(loc)

   def do_showcolonies(self, line):
      ndx = 1
      print 'These are the colonies for player: %s' % self.activePlayer.playerName
      for colony in self.activePlayer.colonymaster:
         print '[%d] %s' % (ndx, colony.name)
         ndx += 1
          
   def help_selectcolony(self):
      print 'select active colony from a numbered list'

   def do_selectcolony(self, line):
      self.do_showcolonies(line)
      choice = gu.get_tty_input('Which one? ')
      print 'You chose [%s]' % choice
      self.activeColony = self.activePlayer.colonymaster[int(choice) - 1]
      loc = self.activeColony.location
      self.activeSector = self.g.locateSector(loc)
   
   def help_showsectors(self):
      print 'dumps details about all known sectors'

   def do_showsectors(self, line):
      print 'ready to dump known sectors'
      self.g.dump()
  
   def do_status(self, line):
      statusstring = '''Active Player: %s
Active Sector: %s
Active Colony: %s
Active Ship: %s''' % (self.activePlayer.playerName, self.activeSector.location.toString(),
                      self.activeColony.name, self.activeShip.name)
      print statusstring
      
   def help_showgameboard(self):
      print 'shows the gameboard as JSON'

   def do_showgameboard(self, line):
      print 'here is the gameoboard as JSON'
      # do the thing here
      # print json.dumps(self.g,enc=MyEncoder) # currently broken
      print self.g.dump()

   def help_dump(self):
      print 'dumps the gameboard'

   def do_dump(self, line):
      print 'printing the gameboard'
      self.g.dump()
   
   def do_quit(self, line):
      return True

   def do_EOF(self, line):
      return True
   
   ############### test routines ##########################   
   def do_showRegistry(self, line):
      self.g.registry.dump()

   def help_jdumpSectors(self):
      print "dump entire sector table as JSON"

   def do_jdumpSectors(self, line):
      print json.dumps(self.g.sectorTable, cls=MyEncoder)
      
   def help_initializeSectors(self):
      print "populate a 14x14 grid of sectors near the origin, then emit the JSON for each sector"

   def do_initializeSectors(self, line):
      for x in range(0, 14):
         if not x in self.g.sectorTable:
            self.g.sectorTable[x] = {}
         for y in range (0, 14):
            # print "x is: |%s| -- and y is: |%s|" % (x,y)
            self.g.sectorTable[x][y] = (Sector(Location(x, y)))
      for x in range(0, 14):
         for y in range(0, 14):
            sect = self.g.sectorTable[x][y]
            print json.dumps(sect, cls=MyEncoder)
      
   def help_name(self):
      print 'test name generator'

   def do_name(self, line):
      # test that we can get a unique new name
      t = gu.NameMaker().grantName()
      print t

   def help_sectorfinder(self):
      print 'find a sector matching cartesian input ie: (x,y)'

   def do_sectorfinder(self, line):
      choice = gu.get_tty_input('x location? ')
      xspot = int(choice)
      choice = gu.get_tty_input('Y location? ')
      yspot = int(choice)
      sect = self.g.locateSector(Location(xspot, yspot))
      sect.dump()

   def help_addplayer(self):
      print 'tests the addplayer functionality'

   def do_addplayer(self, line):
      r = MasterRegistry()
      r.addPlayer(Player('Joan Watson'))
      r.dump()

   def help_saveSectorTable(self):
      print "write out the sector table as JSON file"

   def do_saveSectorTable(self, line):
      print 'ready to write sector table to file'
      f = open("resources/sectortable.json", "w")
      tbl = json.dumps(self.g.sectorTable, cls=MyEncoder)
      f.write(tbl)
      f.close()
      
   def help_readNamesMemory(self):
      print '''simply read from a resource file into memory'''

   def do_readNamesMemory(self, line):
      localnames = []
      print 'ready to read names in'
      f = open("resources/names", "r")
      for n in f:
         localnames.append(n.rstrip('\n\t '))
      f.close()
      for nm in localnames:
         print "another name is: %s" % nm 
      return localnames
         
   def do_bigTable(self, line):
      ''' 
         This routine makes a file that is 25MB in size
         it's just 140x140 - quite a few sectors, but
         not big data by any means      
       '''
      print 'ready to make giant sector table'
      t = self.g.sectorTable
      for x in range(300, 440):
         if not x in t:
            t[x] = {}
         for y in range(300, 440):
            t[x][y] = (Sector(Location(x, y)))
      print 'giant sector table created, now writing...'
      fstore = open('resources/bigSectorTable.json', 'w')
      tbl = json.dumps(t, cls=MyEncoder)
      fstore.write(tbl)
      fstore.close()
      
   def do_selectMapPages(self, line):
      t = self.g.sectorTable
      print 'ready to write out just select pages to a file'
      origins = [[120, 400], [270, 600], [80, 150], [400, 390]]
      for o in origins:
         print 'mapping sectors from origin: %02d,%02d' % (o[0], o[1])
         for x in range(o[0], o[0] + 12):
            if not x in t:
               t[x] = {}
            for y in range(o[1], o[1] + 12):
               t[x][y] = (Sector(Location(x, y)))
         print 'map page created, now to write it to a file...'
         fstore = open('resources/sectorTable.%03d%03d.json' % (o[0], o[1]), 'w')
         tbl = json.dumps(t, cls=MyEncoder)
         fstore.write(tbl)
         fstore.close()
      
   def do_noteEditorTest(self, line):
      done = False
      tempPage = NotePage('')
      print '''
This is simply a test to validate the structure and methods of the
NotePage class. It uses a temporary NotePage that will be destroyed
after the test succeeds.

Type lines of input
End by using a line with only "..."

      '''
      while (done != True):
         # something
         nextLine = gu.get_tty_input('line: ')
         if (nextLine == '...'):
            done = True
         else:
            # add it to the page
            tempPage.setContent(tempPage.getContent() + '\n' + nextLine)
      print 'Here is your page'
      tempPage.dumpContent()        
   
   def do_noteHeaderTest(self, line):
      ''' add a note, add a header, emit the note '''
      n = NotePage('This is your sample note page')
      n.addHeader('Content-Type', 'text/plain')
      
      print 'ready to show message content'
      n.dumpContent()
      
      print 'now a list of headers'
      print n.content['headers'].keys()
      
      print 'now, can we find a specific Header (ie. Content-Type)?'
      print n.hasHeader('Content-Type')
      
      print 'also, change the content string, does that propogate to the object?'
      n.setContent('Another message, in case you are listening.')
      n.dumpContent()  # proves that "content" contains a reference to "contentString"
      
      print 'and now, the entire message:'
      n.dumpEntirely()
      
   def do_makeFile(self,line):
      print 'making a new file'
      fhandle = open('RightHereBeeches','w')
      fhandle.write('words on a page')
      fhandle.close()
      
   def do_noteStorageTest(self, line):
      print 'creates a set of notes and stores them into MessageRegistry'
      lines = self.do_readNamesMemory('blah!')
      line_ct = len(lines)
      # generate some number of messages
      for m in xrange(0, 20):
         # select three random names from lines
         manny = lines[DieRoll(line_ct - 1).roll()]
         moe = lines[DieRoll(line_ct - 1).roll()]
         jack = lines[DieRoll(line_ct - 1).roll()]
         missive = '%s%s%s' % (manny, moe, jack)
         # you can tell when I'm getting loopy
         # store message in Message Registry
         np = NotePage(missive)
         self.g.legend.insertNote(np.noteID, np)
      
      # dump Message Registry
      self.g.legend.dump()
